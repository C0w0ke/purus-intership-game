// node_modules/playcanvas/build/playcanvas/src/core/math/math.js
var math = {
  DEG_TO_RAD: Math.PI / 180,
  RAD_TO_DEG: 180 / Math.PI,
  clamp(value, min, max) {
    if (value >= max) return max;
    if (value <= min) return min;
    return value;
  },
  intToBytes24(i) {
    const r = i >> 16 & 255;
    const g = i >> 8 & 255;
    const b = i & 255;
    return [r, g, b];
  },
  intToBytes32(i) {
    const r = i >> 24 & 255;
    const g = i >> 16 & 255;
    const b = i >> 8 & 255;
    const a = i & 255;
    return [r, g, b, a];
  },
  bytesToInt24(r, g, b) {
    if (r.length) {
      b = r[2];
      g = r[1];
      r = r[0];
    }
    return r << 16 | g << 8 | b;
  },
  bytesToInt32(r, g, b, a) {
    if (r.length) {
      a = r[3];
      b = r[2];
      g = r[1];
      r = r[0];
    }
    return (r << 24 | g << 16 | b << 8 | a) >>> 0;
  },
  lerp(a, b, alpha) {
    return a + (b - a) * math.clamp(alpha, 0, 1);
  },
  lerpAngle(a, b, alpha) {
    if (b - a > 180) {
      b -= 360;
    }
    if (b - a < -180) {
      b += 360;
    }
    return math.lerp(a, b, math.clamp(alpha, 0, 1));
  },
  powerOfTwo(x) {
    return x !== 0 && !(x & x - 1);
  },
  nextPowerOfTwo(val) {
    val--;
    val |= val >> 1;
    val |= val >> 2;
    val |= val >> 4;
    val |= val >> 8;
    val |= val >> 16;
    val++;
    return val;
  },
  nearestPowerOfTwo(val) {
    return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));
  },
  random(min, max) {
    const diff = max - min;
    return Math.random() * diff + min;
  },
  smoothstep(min, max, x) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep(min, max, x) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  roundUp(numToRound, multiple) {
    if (multiple === 0) return numToRound;
    return Math.ceil(numToRound / multiple) * multiple;
  },
  between(num, a, b, inclusive) {
    const min = Math.min(a, b);
    const max = Math.max(a, b);
    return inclusive ? num >= min && num <= max : num > min && num < max;
  }
};

// node_modules/playcanvas/build/playcanvas/src/core/math/random.js
var _goldenAngle = 2.399963229728653;
var random = {
  circlePoint(point) {
    const r = Math.sqrt(Math.random());
    const theta = Math.random() * 2 * Math.PI;
    point.x = r * Math.cos(theta);
    point.y = r * Math.sin(theta);
  },
  circlePointDeterministic(point, index, numPoints) {
    const theta = index * _goldenAngle;
    const r = Math.sqrt(index) / Math.sqrt(numPoints);
    point.x = r * Math.cos(theta);
    point.y = r * Math.sin(theta);
  },
  spherePointDeterministic(point, index, numPoints, start = 0, end = 1) {
    start = 1 - 2 * start;
    end = 1 - 2 * end;
    const y = math.lerp(start, end, index / numPoints);
    const radius = Math.sqrt(1 - y * y);
    const theta = _goldenAngle * index;
    point.x = Math.cos(theta) * radius;
    point.y = y;
    point.z = Math.sin(theta) * radius;
  },
  radicalInverse(i) {
    let bits = (i << 16 | i >>> 16) >>> 0;
    bits = ((bits & 1431655765) << 1 | (bits & 2863311530) >>> 1) >>> 0;
    bits = ((bits & 858993459) << 2 | (bits & 3435973836) >>> 2) >>> 0;
    bits = ((bits & 252645135) << 4 | (bits & 4042322160) >>> 4) >>> 0;
    bits = ((bits & 16711935) << 8 | (bits & 4278255360) >>> 8) >>> 0;
    return bits * 23283064365386963e-26;
  }
};

export {
  math,
  random
};
//# sourceMappingURL=chunk-TT7XWIAI.js.map
